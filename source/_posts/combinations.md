---
title: Generating All Unique Subsequences And Sorting
date: 2016-01-15 22:06:50
tags:
  - javascript 
  - combinatorics
  - algorithms
---

## The Challenge

We recently received a code challenge similar to the following here at [Coding House](https://codinghouse.co/): _Given a string `str`, generate a lexicographically sorted array containing all unique subsequences of `str`._ Challenge accepted!

There are two parts to this problem: (1) generating the subsequences and (2) returning a sorted array. Although they will end up intertwined, I'll treat them one at a time.

## Generating The Subsequences

A subsequence of `str` is generated by deleting one or more letters of `str` while keeping the others. For example, if `str` is `'abcd'`, then several (not all) subsequences are

```javascript
'abcd'
'b'
'bd'
'acd'
```

The trick is to think of this as "which letters are we keeping vs. which are we throwing out?" Let's rewrite each of the above subsequences taking note of which letters were kept from the original `str`:

```bash
    a b c d       a b c d       a b c d       a b c d
    1 1 1 1       0 1 0 0       0 1 0 1       1 0 1 1

->  a b c d         b             b   d       a   c d
```

Aha! Each subsequence of `'abcd'` corresponds with a binary number between `0000` and `1111`. Thus, to generate all subsequences, we need only iterate through all numbers from 0 up through 2^4 - 1 and map each number to its corresponding subsequence. Let's put that into code.

Our `for` loop will start at 0 and go up to 2^n. An easy way to calculate 2^n is with the expression `1 << n`, using the [bitshift operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators). On each iteration, we need to take the iteration variable (let's call it `i`) and turn it into a binary string of the right length. We can convert `i` to binary with `i.toString(2)`, but this will output a string like so:

```javascript
(0).toString(2) -> "0"
(3).toString(2) -> "11"
(5).toString(2) -> "101"
```

We want to pad this binary string with zeros. There are multiple ways to do this. I'll use

```javascript
var padding = '0'.repeat(str.length - 1); // generate something like '000'
var binary = (padding + i.toString(2)).slice(-str.length);
```

The last piece of the puzzle is to map this string `binary` to the subsequence it represents. That's fairly straightforward. We split `binary` into an array, map it, then join it:

```javascript
binary.split('').map((x, index) => x === '1' ? str[index] : '').join('')
```

## Sorting The Output Array

We've almost got a working piece of code! We just need to store the generated subsequences somewhere. An easy option is to use a [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set), which will take care of uniqueness for us. When we're done with the generating, we can just convert the Set to an Array, sort it, and return it. Let's see what we have:

```javascript
function subsequences(str) {
  var subseqs = new Set(); // initialize an empty Set
  var padding = '0'.repeat(str.length - 1); // this doesn't need to be inside the loop

  for (var i = 0; i < (1 << str.length); i++) {
    var binary = (padding + i.toString(2)).slice(-str.length);
    var subseq = binary.split('')
                       .map((x, index) => x === '1' ? str[index] : '')
                       .join('');
    subseqs.add(subseq); // insert a new subsequence ONLY IF it's not already in 'subseqs'
  }

  return Array.from(subseqs).sort();
}
```

This works! Woohoo! Try it out.

However... we can do better. Basically, we want to maintain a sorted collection as we add subsequences. We need two things to do so efficiently: an algorithm and a suitable data structure. I'm thinking of binary insertion for the algorithm. But can you think of a suitable data structure? Arrays have linear insertion -- that's no good. Is there some kind of tree that will work? I'll let you ponder that. :)

_TO BE CONTINUED_
